



10:25
fixed duration

variable frame rate displays
basically normal monitors from today have some frame rate that they update the image at. So whatever that monitor frame rate is, that is also the frame rate that we want our game to be updating at.


we want the monitor to update roughly the same frame as our game does.

That's the goal


we can either do the exact rate of your monitor frame rate, or any subdivision of it. Let say your monitor is at 120 hz, u can do it at 60 fps





17:55


for me whenever I do a game loop and whenever I am looking at timing stuff, I want to have a target framerate,
and we try very hard to hit that framerate

and for some reason if we don't hit that framerate, we set a new lower frame rate. We always try to stay fixed at whatever target framerate is.

I never want the framerate to be variable, becuz there is no way to make that work properly, your physics is always wrong if you do that.






19:45
the problem with the audio is that, we would like to feed the amount of audio needed for that frame. But if we do that, we run the risk of missing, causing frame lag.

We have some choices, 

always hit
overwrite next frame
frame of lag
guard thread


option 1 is the easier and easiest.





25:01
figure out refresh rate of our monitor


44:03
You can't use __rdtsc() for timing on a user machine. you can only use query performance counter for timings on a user machine. So our game code has to be driven off of query performance counter.


__rdtsc is only for profiling cuz how it behaves varies from CPU to CPU. so you don't want to ship a game using rdtsc for game time.



49:09

we don't want the CPU wasting CPU cycles in that while loop and checking the performacnce counter



51:00
there is a problem with the sleep method
The sleep function in windows has a certain granularity with how long it can put your thread to sleep. 
Essentially, if it decides to put your thread to sleep, it is going to wait for the next scheduler granularity to wake you up. 

Inside every OS, there's some code called the scheduler. The scheudler is what decides when threads run. Its pretty much the thing that makes your OS preemptively multitask. 

The scheduler is something that has to interrupts what's going on. 

so if the scheduler only wakes up every 15 milli seconds to check if anyone wants to wake up, and you request to sleep for 2 milli seocnds, you are realistically gonna sleep for 15 milli seconds.

so you fix this with timeBeginPeriod.

